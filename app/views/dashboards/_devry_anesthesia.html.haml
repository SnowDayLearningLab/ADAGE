- pulse_scores = []
- asa_scores = []

- count = AdaData.with_game(@game.name).include_filters(@filters).where(key: :ADAGESessionEnd).count
- total_time = 0
- AdaData.with_game(@game.name).include_filters(@filters).where(key: :ADAGESessionEnd).pluck(:duration).each do |duration|
  - total_time += duration.to_i
- total_time /= 1000
- avg_time = total_time/count

- avg_pex = []
- AdaData.with_game(@game.name).include_filters(@filters).where(key: :ContextEnd_Spinner,name: "PEx Pulse").inject({}) do |record,event|
  - ( record[Time.at(event.timestamp.to_i/1000).strftime("%m/%d/%y")] ||= [] ) << event.score
  - record
  - avg_pex = record
- avg_pex.keys.each do |key|
  - avg_pex[key] = avg_pex[key].inject{ |sum, el| sum + el }.to_f / avg_pex[key].size

- avg_asa = []
- AdaData.with_game(@game.name).include_filters(@filters).where(key: :ContextEnd_Spinner,name: "ASA-PS Score").inject({}) do |record,event|
  - ( record[Time.at(event.timestamp.to_i/1000).strftime("%m/%d/%y")] ||= [] ) << event.score
  - record
  - avg_asa = record
- avg_asa.keys.each do |key|
  - avg_asa[key] = avg_asa[key].inject{ |sum, el| sum + el }.to_f / avg_asa[key].size


- @users.each do |user_id|
  - end_log = AdaData.with_game(@game.name).include_filters(@filters).where(key: :ContextEnd_Spinner,user_id: user_id.to_i,name: "PEx Pulse").last

  - if end_log
    - start_log = AdaData.with_game(@game.name).include_filters(@filters).where(client_id: end_log.startContextID).first

    - AdaData.with_game(@game.name).include_filters(@filters).between(_id: start_log._id..end_log._id).where(key: :PlayerEvent_SpinnerOutput,user_id: user_id).each do |record|
      - pulse_scores << record.attempt

  - asa = AdaData.with_game(@game.name).include_filters(@filters).where(key: :ContextEnd_Spinner,user_id: user_id,name: "ASA-PS Score").last
  - if asa
    - asa_scores << asa.score

- pie = Array.new
- AdaData.with_game(@game.name).include_filters(@filters).only(:name,:duration).where(key: :ContextEnd_GameSection).group_by(&:name).each do |name, event|
  - pie << [ name,event.inject(0){|sum,e| sum += e.duration.to_i }]

:javascript

  function Histogram(data){
    var self = this;
    self.convert = function(bin){
      if(!self.init && self.bin !=bin){
        var min_num = Math.min.apply(Math,self.data);
        var max_num = Math.max.apply(Math,self.data);

        var w = (max_num - min_num)/bin;

        self.ticks = [];
        self.values = [];

        for(var i=0; i < bin;i++){
          var min = i*w+min_num;
          var max = (i+1)*w+min_num;
          self.values[i] = 0;
          self.ticks[i] = min;
          self.data.forEach(function(score){
            if(score >= min && score <=max){
              self.values[i] += 1;
            }
          });
        }

        self.init = true;
      }
    };

    self.getValues = function(bin){
      self.convert(bin);

      if(self.values[0] !='') self.values.unshift('');
      return self.values;
    };

    self.getLabels = function(bin){
      self.convert(bin);
      if(self.ticks[0] !='x') self.ticks.unshift('x');
      return self.ticks;
    };

    function Histogram(){
      self.data = data;
      self.init = false;
      self.bin = 0;
      self.ticks = [];
      self.values = [];
    };

    return Histogram();
  };


  $(document).ready( function() {
    var pulse = new Histogram(#{pulse_scores});
    var asa = new Histogram(#{asa_scores});

    c3.generate({
      bindto: "#pulse-check",
      data: {
        type: 'bar',
        x: 'x',
        columns: [
          pulse.getLabels(6),
          pulse.getValues(6),
        ]
      },
      bar: {
        width: {
            ratio: 0.5
        }
      },
      axis: {
        x: {
          label: {
            text: '',
            position: 'outer-center'
          },
          tick: {
            format: function(x){
              return x.toFixed(0);
            }
          }
        },
        y: {
          label: {
              text: 'Number of Students',
              position: 'outer-middle'
          },
          tick: {
            format: function(x){
              return (x == Math.floor(x)) ? x: "";
            }
          }
        }
      },
      legend: {
        show: false
      }
    });

    c3.generate({
      bindto: "#asa-ps",
      data: {
        type: 'bar',
        x: 'x',
        columns: [
          asa.getLabels(6),
          asa.getValues(6),
        ]
      },
      bar: {
        width: {
            ratio: 0.5
        }
      },
      axis: {
        x: {
          label: {
            text: '',
            position: 'outer-center'
          },
          tick: {
            format: function(x){
              return x.toFixed(1);
            }
          }
        },
        y: {
          label: {
            text: 'Number of Students',
            position: 'outer-middle'
          },
          tick: {
            format: function(x){
              return (x == Math.floor(x)) ? x: "";
            }
          }
        }
      },
      legend: {
        show: false
      }
    });

    c3.generate({
      bindto: "#pie",
      size: {
        width: 130,
        height: 130
      },
      data: {
          columns: #{pie},
          type : 'pie',
      },
      pie: {
        label: {
          format: function (value, ratio, id) {
            return moment(new Date(value/1000)).format('h:mm:ss');    
          }
        }
      },
      legend: {
        show: false
      }
    });

    var asa_scores = #{avg_asa.to_json};

    var labels =[];

    var scores = []
    for(var key in asa_scores){
      labels.push(new Date(key).getTime());
      scores.push(asa_scores[key]);
    }
    labels.unshift('x');
    scores.unshift('');
    c3.generate({
      bindto: "#asa-line",
      data: {
        x: 'x',
        x_format : '%Y%m%d',
        columns: [
          labels,
          scores
        ]
      },
      axis: {
        x: {
          type : 'timeseries',
          label: {
            text: 'Date',
            position: 'outer-center'
          }
        },
        y: {
          label: {
            text: 'Avg Score',
            position: 'outer-middle'
          },
          tick: {
            format: function(y){
              return y.toFixed(1);
            }
          }
        }
      },
      legend: {
        show: false
      }
    });

    var pex_scores = #{avg_pex.to_json};

    var labels = [];

    var scores = []
    for(var key in pex_scores){
      labels.push(new Date(key).getTime());
      scores.push(pex_scores[key]);
    }

    labels.unshift('x');
    scores.unshift('');

    c3.generate({
      bindto: "#pex-line",
      data: {
        x: 'x',
        x_format : '%Y%m%d',
        columns: [
          labels,
          scores
        ]
      },
      axis: {
        x: {
          type : 'timeseries',
          label: {
            text: 'Date',
            position: 'outer-center'
          },
          tick: {
            fit: true
          }
        },
        y: {
          label: {
              text: 'Avg Score',
              position: 'outer-middle'
          },
          tick: {
            format: function(x){
              return x.toFixed(1);
            }
          }
        }
      },
      legend: {
        show: false
      }
    });


  });

.content.full
  .container
    .two_thirds.left
      %p 
        Total time spent playing:
        = Time.at(total_time).utc.strftime("%H:%M:%S")
      %p 
        Average time spent playing: 
        = Time.at(avg_time).utc.strftime("%H:%M:%S")
    .one_third.right
      #pie.right

.content.full
  .container
    %p.header Physical Exam
    .one_half.left.graph
      .title.center_text Pulse Check (Most Recent Play)
      #pulse-check

    .one_half.right.graph
      .title.center_text ASA-PS Score (Most Recent Play)
      #asa-ps
    .content
      .one_half.left.graph
        .title.center_text Pulse Check Score
        #pex-line

      .one_half.right.graph
        .title.center_text ASA-PS Score
        #asa-line